#include <iostream>
#include <set>
#include <algorithm>
#include <cstring>

using namespace std;
const int MAX = 10001;
// 문제
// 어제, 그리고 어제 어제 단체달리기를 두 번이나 하였다. 원장선생님의 이러한 하드 트레이닝으로 월드 학생들의 체력은 거의 박지성 수준이 되었다. 그래서 월드 학생들은 운동장을 도는데 정확히 N분에 완주할 수 있는 시간 안배능력까지 갖추게 되었다.
// 그래서 N분동안 학생들은 달릴지 아님 쉴지 결정하여야 한다. 그러나 학생들도 인간이기 때문에 계속 달릴 수는 없다. “지침 지수”라는 것이 있어서 1분을 달린다면 “지침 지수”는 1이 올라간다. 반대로 1분을 쉰다면 “지침 지수”는 1이 내려간다. 또한 이 “지침 지수”가 M보다 커지면 학생들은 더 이상 달릴 수가 없다.
// 아주 특이하게도 학생들은 시간에 따라 달릴 수 있는 거리가 다르다. 만약 I분에 달렸다면 Di 만큼의 거리를 달릴 수 있다. (i분을 달렸다는 것이 아니라 I분이 되는 때에 달렸다는 뜻임) 또한 학생들이 쉬기 시작하면 지침지수가 0이 되기 전에는 다시 달릴 수가 없다.
// 물론 이 달리기가 끝나면 학생들은 다시 공부를 해야한다. 그렇기 때문에 달리기가 끝난다음 지침지수가 0이 되지 않는다면 맑은 정신으로 문제를 풀 수가 없기 때문에 달리기가 끝나면 지침지수는 0이 되어야 한다.
// 월드학생들이 최대한 멀리 갈 수 있는 거리를 구해보자.
// ---------------------------------
// 입력
// 첫째 줄에 운동할 시간 N(1 ≤ N ≤ 10000)과 M(1 ≤ M ≤ 500)이 주어진다. 이어서 N개의 줄에 i분에 달릴수 있는 거리 Di(0 ≤ Di ≤ 10,000)가 차례차례 주어진다.
// ---------------------------------
// 출력
// 첫째 줄에 최대로 멀리 갈 수 있는 거리를 출력하라.
// ---------------------------------
// 문제 해석
// 매 순간(I분)마다 달릴 때 값과 달리지 않을 때 값을 체크
// 만약 쉬고 있다면 0이 될 때 까지 달리지 못한다.

// 1. 쉬고 있을 때 지침 지수는 어떻게 확인해야 하나?
// 2. 전에 상태는 어떤 방법으로 확인해야 하나? -> 굳이 확인하지 않고 i-1 분의 순간에서 가장멀리 간 상태를 확인하면 되지 않나?


// 점화식 
// 달릴때 : dp[x][0] = max(dp[x-1][0], dp[x-1][1]) + arr[x]; / + 지침 지수++ , but 지침 지수 > M 이면 달릴 수 없어
// 쉴 때 : dp[x][1] = max(dp[x-1][0], dp[x-1][1]) + 0; / + 지침 지수-- , and 지침 지수 0이 될 때 까지는 쉬어야 해

// 근데 그냥 점화식 말고 재귀로 풀면 안되려나 ?
// 재귀로 매 순간 (분, 저번 상태, 지침 지수, 간 거리) 로 해서 각 상태별로 재귀를 한다면?

int dp[MAX][502][2];
int arr[MAX];
int n, m, answer;

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    
    cin >> n >> m;
    for(int i=1; i<=n; i++){
        cin >> arr[i];
    }
    dp[1][1][1] = arr[1];
    dp[1][0][0] = 0;
    
    for(int i=2; i<=n; i++) {
        for(int j=0; j<=m; j++) {
            if(j != 1) {
                if(j != 0) { 
                    dp[i][j][1] = dp[i - 1][j - 1][1] + arr[i];
                    dp[i][j][0] = max(dp[i - 1][j + 1][0], dp[i - 1][j + 1][1]);
                }
                else {
                    dp[i][j][0] = max(max(dp[i -1][j + 1][0], dp[i - 1][j + 1][1]), dp[i - 1][j][0]);
                }
            }
            else{
                dp[i][j][0] = max(dp[i - 1][j + 1][0], dp[i - 1][j + 1][1]);
                dp[i][j][1] = max(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]) + arr[i];
            }
        }
    }
    cout << dp[n][0][0] << endl;
    return 0;
}