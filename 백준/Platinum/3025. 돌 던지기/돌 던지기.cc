#include <cstdio>
#include <vector>
#include <stack>
#include <set>
using namespace std;
using pii = pair<int, int>;
// 문제
// 이 모든 사건의 시작은 2주 전이었다. 그 날 상근이는 복도에 누워서 잠을 자고 있었다.
//  커다란 돌을 들고 그 옆을 지나가던 민혁이는 복도에서 잠을 자는 사람을 처음봐서 신기하게 쳐다보고 있었다. 그 때였다.
//  들고 있던 돌을 상근이의 왼 발에 떨어뜨렸다. 상근이는 응급실로 실려갔고, 한 달 동안 침대에 누워서 휴식을 취해야 한다는 진단을 받았다.
// 민혁이는 미안한 마음에 하던 일을 모두 중단하고 상근이를 간호하기로 했다.
// 상근이는 2주 동안 온라인 저지 문제를 풀었다. 2주 동안 문제를 풀다보니 게임을 하고 싶어졌고, 마침 민혁이를 이용해서 게임을 하기로 했다.
// 상근이의 게임은 R×C 보드를 세워놓은 상태에서 진행한다. 맨 처음에 각 정사각형 칸은 비어있거나 벽으로 막혀있다.
// 상근이는 민혁이에게 돌을 떨어놓을 열을 지시하고, 민혁이는 가장 윗 행의 그 열에 돌을 놓는다. 돌을 놓은 이후에는 중력에 의해서 돌이 떨어지게 된다.
// 돌에 작용하는 중력은 다음과 같다.
// 1. 돌의 아랫칸이 벽으로 막혀있거나 가장 아랫줄이라면, 돌은 그 자리에 그대로 멈춰 있는다.
// 2. 돌의 아랫칸이 비어있다면, 돌은 아랫칸으로 이동한다.
// 3. 돌의 아랫칸에 돌이 있다면, 돌은 다음과 같이 미끄러진다.
//  3-1. 만약 돌의 왼쪽 칸과 왼쪽-아래 칸이 비어있다면, 돌은 왼쪽으로 미끄러진다.
//  3-2. 만약 돌이 왼쪽으로 미끄러지지 않았고, 오른쪽 칸과 오른쪽-아래 칸이 비어있다면, 돌은 오른쪽으로 미끄러진다.
//  3-3. 위의 두 경우가 아니라면 돌은 그 자리에 멈추고, 다시는 움직이지 않는다.
// 민혁이는 돌의 이동이 멈춘 이후에 다른 돌을 던지기 시작한다.
// 보드의 초기 상태와 민혁이가 돌을 놓은 열의 번호가 순서대로 가 주어졌을 때, 모든 돌을 던진 이후에 보드의 상태를 구하는 프로그램을 작성하시오.
// 민혁이는 항상 제일 윗 칸이 비어있는 칸에만 돌을 던진다.
// --------------------------------------------------------------------------------------------------------------
// 입력
// 첫째 줄에 보드의 크기 R과 C가 주어진다. (1 ≤ R ≤ 30,000, 1 ≤ C ≤ 30)
// 다음 R개 줄에는 C개의 문자가 주어지며, 보드의 초기 상태이다. '.'는 빈 칸, 'X'는 벽으로 막힌 곳을 나타낸다.
// 다음 줄에는 돌을 던진 횟수 N이 주어진다. (1 ≤ N ≤ 100,000)
// 다음 N개 줄에는 돌을 던진 열의 위치가 순서대로 주어진다. (가장 왼쪽 열의 번호는 1번)
// --------------------------------------------------------------------------------------------------------------
// 출력
// 총 R개 줄에 걸쳐서 보드의 게임이 모두 끝난 후의 상태를 출력한다. 돌은 'O'로 출력한다.
// --------------------------------------------------------------------------------------------------------------

int r, c, q;
char b[30003][33], tmp[2];
set<int> top[33];
pii rec[33][30003];
int idx[33];

// origin : 최초에 어느 열에서 떨어뜨린건지
// row, col : 떨어뜨릴 돌의 현재 행과 열
void simulate(int row, int col, int origin)
{
    // (row, col) 에서 떨어져 처음 부딪히는 가장 높은 빈칸의 높이
    int h = *(top[col].upper_bound(row));

    if (b[h][col] == 'O')
    {
        if (b[h][col - 1] == '.' && b[h - 1][col - 1] == '.')
        {
            rec[origin][idx[origin]] = {h - 1, col};
            idx[origin]++;
            simulate(h - 1, col - 1, origin);
        }
        else if (b[h][col + 1] == '.' && b[h - 1][col + 1] == '.')
        {
            rec[origin][idx[origin]] = {h - 1, col};
            idx[origin]++;
            simulate(h - 1, col + 1, origin);
        }
        else
        {
            b[h - 1][col] = 'O';
            top[col].erase(h);
            top[col].insert(h - 1);
        }
    }
    else
    {
        b[h - 1][col] = 'O';
        top[col].erase(h);
        top[col].insert(h - 1);
    }
}

void output()
{
    for (int i = 1; i <= r; ++i)
        printf("%s\n", b[i] + 1);
}

int main()
{
    scanf("%d %d", &r, &c);
    for (int i = 1; i <= r; ++i)
    {
        for (int j = 1; j <= c; ++j)
        {
            scanf("%1s", &tmp);
            b[i][j] = tmp[0];
            if (b[i][j] == 'X')
                top[j].insert(i);
        }
    }
    for (int i = 1; i <= c; ++i)
    {
        top[i].insert(r + 1);
    }

    scanf("%d", &q);
    while (q--)
    {
        int col;
        scanf("%d", &col);

        int r, c;
        while (idx[col] > 0)
        { // col열에서 떨어뜨린 돌의 체크포인트 개수
            r = rec[col][idx[col] - 1].first;
            c = rec[col][idx[col] - 1].second;
            if (b[r][c] != '.')
                --idx[col];
            else
                break;
        }
        if (idx[col] == 0)
        { // '.'인 체크포인트가 없으면 처음부터 시뮬레이션
            simulate(1, col, col);
        }
        else
        { // '.'인 체크포인트가 있으면 그 지점에서부터 시뮬레이션
            simulate(r, c, col);
        }
    }
    output();
    return 0;
}
